using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections;
class program
{   
    static ArrayList NewStates; // новые состояния 
 
    static string MakeStateName(string state)
 
    // создать имя состояния // по двоичной записи
    {
        string result = "{";
 
        for (int i = 0; i < state.Length; i++) // единица превращается 
            if (state[i] == '1') // в номер состояния
                result += Convert.ToString(i + 1) + " ";
        result += "}";
        return result;
    }
 
    static void GenerateNewStates(int depth, string s) // сгенерировать
                                                       // набор состояний 
    { if (depth == 0)                                   // нового автомата
            NewStates.Add(MakeStateName(s));
        else
        {
 
            GenerateNewStates(depth - 1, "0" + s);
            GenerateNewStates(depth - 1, "1" + s);
        }
    }
    // структуры взятые из алгоритма минимизации
    struct Pair // пара состояний (p, q)
 
    {
        public int p, q;
 
        public Pair(int thep, int theq) { p = thep; q = theq; }
 
    }
    struct Leftside //левая часть правила -(состояние,символ)
    {
        public int state;
        public char symbol;
 
        public Leftside(int st, char sym) { state = st; symbol = sym; }
    } // Nepawd WcTb NpaBuna
 
    static void Main(string[] args)
 
    {
 
        int Nstates = Convert.ToInt32(Console.In.ReadLine()); // количество состояний
        NewStates = new ArrayList();
        GenerateNewStates(Nstates, "");
        // создаем набор новых состояний
        NewStates.RemoveAt(0); // стираем состояние помеченное пустым множетсвом 
                               // оно первое в списке
                               // взято из программы минимизации автомата
        string[] symstr = (Console.In.ReadLine()).Split(' ');
        char[] symbols = new char[symstr.Length];
        for (int i = 0; i < symstr.Length; i++)
 
            symbols[i] = Convert.ToChar(symstr[i]); // символы входной ленты
 
        // список допускающих состояний
        string[] Flist = (Console.In.ReadLine()).Split(' ');
        bool[] favorable = new bool[Nstates + 1];
        for (int i = 1; i <= Nstates; i++)
            favorable[i] = false;
        foreach (string id in Flist)
            favorable[Convert.ToInt32(id)] = true;
 
        // стартовое состояние
        int StartingState = Convert.ToInt32(Console.In.ReadLine()); // процедура считывания правил модифицирована 
                                                                    // (чтобы недетерминированные переходы отрабатывались корректно ) 
        Hashtable rules = new Hashtable();
 
        string s;
        while ((s = Console.In.ReadLine()) != " ") // считывание правил
        {
 
            string[] tr = s.Split(' ');
            Leftside ls = new Leftside(Convert.ToInt32(tr[0]), Convert.ToChar(tr[1]));
            if (!rules.ContainsKey(ls))
                rules.Add(ls, new SortedList());
 
            // правая часть правила-множество состояний,
 
            // куда ведет переход
 
            ((SortedList)rules[ls]).Add(Convert.ToInt32(tr[2]), null);
 
        }
        
 
 
 
 
    Console.Write("Стартовое состояние: {{{0}}}\n" + "допускающие состояния: ", StartingState);
 
// вывод допускающих состояний
    for (IEnumerator state = NewStates.GetEnumerator(); 
        state.MoveNext();)
        for(int i = 1; i <= Nstates; i++)
        if (favorable[i]) // если состояние i допускающее 
        { // любое состояние нового автомата,  содержищее i тоже допускается
            if (((string)state.Current).IndexOf(" " + Convert.ToString(i) + " ") != -1)
            {
                Console.Write(state.Current + " ");
                break;
            }
 
        }
Console.WriteLine("\n правила: ");
 
        // алгоритм детирминизации      
        for (IEnumerator state = NewStates.GetEnumerator();
            state.MoveNext();)
 
            foreach (char c in symbols) // для каждого состояния  State и символа с
            {
 
                Hashtable R = new Hashtable();
 
                // вычисляем элементы составного 
 
                // состояния (S1, ..., Sn)
                string[] state_elems = ((string)state.Current).Split(' ');
                for (int i = 1; i < state_elems.Length - 1; i++)
                {
                    // для каждого элемента Si 
                    int Si = Convert.ToInt32(state_elems[i]);
                    // если сущесвует правило с левой частью  (Si, c) 
                    //записываем в  R состояния, куда можно
                    // попасть из Si no c 
                    if (rules.ContainsKey(new Leftside(Si, c)))
                        foreach (int r_state in ((SortedList)rules[new Leftside(Si, c)]).Keys)
                            R[r_state] = 1;
                }
 
                if (R.Keys.Count > 0) // Если R не пусто
                {
 
                    // Формируем правую часть в виде строки
                    string right_side = " ";
                    foreach (int r_state in R.Keys)
                        right_side = Convert.ToString(r_state) + " " + right_side;
                    right_side = "{" + right_side + "}";
 
                    //  Выводим готовое правило на экран
                    Console.WriteLine((string)state.Current + ", " + c + " -> " + right_side);
                }
            }
    }
